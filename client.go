// Code generated by goctl-sdk. DO NOT EDIT.

package levee

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// ClientOption is a function that configures the Client.
type ClientOption func(*Client)

// WithHTTPClient sets a custom HTTP client.
func WithHTTPClient(httpClient *http.Client) ClientOption {
	return func(c *Client) {
		c.httpClient = httpClient
	}
}

// WithTimeout sets the timeout for HTTP requests.
func WithTimeout(timeout time.Duration) ClientOption {
	return func(c *Client) {
		c.httpClient.Timeout = timeout
	}
}

// Client is the Levee API client.
type Client struct {
	apiKey     string
	baseURL    string
	httpClient *http.Client


	// Products provides access to products resources.
	Products *ProductsResource
	// Quizzes provides access to quizzes resources.
	Quizzes *QuizzesResource
	// Content provides access to content resources.
	Content *ContentResource
	// Emails provides access to emails resources.
	Emails *EmailsResource
	// Llm provides access to llm resources.
	Llm *LlmResource
	// Site provides access to site resources.
	Site *SiteResource
	// Stats provides access to stats resources.
	Stats *StatsResource
	// Tracking provides access to tracking resources.
	Tracking *TrackingResource
	// Contacts provides access to contacts resources.
	Contacts *ContactsResource
	// Offers provides access to offers resources.
	Offers *OffersResource
	// Orders provides access to orders resources.
	Orders *OrdersResource
	// Events provides access to events resources.
	Events *EventsResource
	// Workshops provides access to workshops resources.
	Workshops *WorkshopsResource
	// Auth provides access to auth resources.
	Auth *AuthResource
	// Billing provides access to billing resources.
	Billing *BillingResource
	// Sequences provides access to sequences resources.
	Sequences *SequencesResource
	// Webhooks provides access to webhooks resources.
	Webhooks *WebhooksResource
	// Funnels provides access to funnels resources.
	Funnels *FunnelsResource
	// Lists provides access to lists resources.
	Lists *ListsResource
	// Customers provides access to customers resources.
	Customers *CustomersResource
}

// NewClient creates a new Levee API client.
// baseURL is required - this is a self-hosted system, use your Levee instance URL.
func NewClient(apiKey string, baseURL string, opts ...ClientOption) (*Client, error) {
	if apiKey == "" {
		return nil, fmt.Errorf("api key is required")
	}
	if baseURL == "" {
		return nil, fmt.Errorf("base URL is required")
	}

	c := &Client{
		apiKey:  apiKey,
		baseURL: strings.TrimSuffix(baseURL, "/"),
		httpClient: &http.Client{
			Timeout: 30 * time.Second,
		},
	}

	for _, opt := range opts {
		opt(c)
	}


	c.Products = &ProductsResource{client: c}
	c.Quizzes = &QuizzesResource{client: c}
	c.Content = &ContentResource{client: c}
	c.Emails = &EmailsResource{client: c}
	c.Llm = &LlmResource{client: c}
	c.Site = &SiteResource{client: c}
	c.Stats = &StatsResource{client: c}
	c.Tracking = &TrackingResource{client: c}
	c.Contacts = &ContactsResource{client: c}
	c.Offers = &OffersResource{client: c}
	c.Orders = &OrdersResource{client: c}
	c.Events = &EventsResource{client: c}
	c.Workshops = &WorkshopsResource{client: c}
	c.Auth = &AuthResource{client: c}
	c.Billing = &BillingResource{client: c}
	c.Sequences = &SequencesResource{client: c}
	c.Webhooks = &WebhooksResource{client: c}
	c.Funnels = &FunnelsResource{client: c}
	c.Lists = &ListsResource{client: c}
	c.Customers = &CustomersResource{client: c}

	return c, nil
}

// request performs an HTTP request and decodes the response.
func (c *Client) request(ctx context.Context, method, path string, query url.Values, body interface{}, result interface{}) error {
	reqURL := c.baseURL + path
	if len(query) > 0 {
		reqURL += "?" + query.Encode()
	}

	var bodyReader io.Reader
	if body != nil {
		jsonBody, err := json.Marshal(body)
		if err != nil {
			return fmt.Errorf("failed to marshal request body: %w", err)
		}
		bodyReader = bytes.NewReader(jsonBody)
	}

	req, err := http.NewRequestWithContext(ctx, method, reqURL, bodyReader)
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}

	req.Header.Set("X-API-Key", c.apiKey)
	req.Header.Set("Content-Type", "application/json")

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		bodyBytes, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("API error (status %d): %s", resp.StatusCode, string(bodyBytes))
	}

	if resp.StatusCode == http.StatusNoContent || result == nil {
		return nil
	}

	if err := json.NewDecoder(resp.Body).Decode(result); err != nil {
		return fmt.Errorf("failed to decode response: %w", err)
	}

	return nil
}
